#!/usr/bin/env python3
"""
Hybrid RAG: Combining Semantic Search + Knowledge Graph
────────────────────────────────────────────────────────────────────────
This lab demonstrates TRUE hybrid RAG with complementary retrieval methods:
1. Semantic search - finds conceptually related content (meaning)
2. Graph search - traverses entity relationships (structure)
3. Hybrid - combines both for precision + flexibility
4. LLM Generation - produces grounded answers from retrieved context

Key insight: Semantic understands MEANING, Graph understands STRUCTURE.
Together they provide both flexibility and precision.

Prerequisites:
- ChromaDB populated with OmniTech documents (from earlier labs)
- Neo4j running with OmniTech graph (./neo4j-setup.sh 3)
"""

import requests
from typing import List, Dict
from chromadb import PersistentClient
from chromadb.config import Settings, DEFAULT_TENANT, DEFAULT_DATABASE
from py2neo import Graph

# ═══════════════════════════════════════════════════════════════════
# Configuration
# ═══════════════════════════════════════════════════════════════════

CHROMA_PATH = "./chroma_db"
COLLECTION_NAME = "pdf_documents"
NEO4J_URI = "neo4j://localhost:7687"
NEO4J_AUTH = ("neo4j", "neo4jtest")
OLLAMA_URL = "http://localhost:11434/api/generate"
OLLAMA_MODEL = "llama3.2:3b"


class HybridRAG:
    """Complete RAG system with semantic search + knowledge graph + LLM generation."""

    def __init__(self):
        self.collection = None
        self.graph = None
        self._connect_chromadb()
        self._connect_neo4j()

    def _connect_chromadb(self):
        """Connect to ChromaDB for semantic search."""
        print("Connecting to ChromaDB...")
        client = PersistentClient(path=CHROMA_PATH, settings=Settings(),
                                  tenant=DEFAULT_TENANT, database=DEFAULT_DATABASE)
        self.collection = client.get_collection(name=COLLECTION_NAME)
        count = self.collection.count()
        print(f"  Loaded {count} document chunks")

    def _connect_neo4j(self):
        """Connect to Neo4j knowledge graph."""
        print("Connecting to Neo4j...")
        try:
            self.graph = Graph(NEO4J_URI, auth=NEO4J_AUTH)
            # Verify connection by counting nodes
            result = self.graph.run("MATCH (n) RETURN count(n) as count").data()
            count = result[0]['count'] if result else 0
            print(f"  Loaded {count} graph nodes")
        except Exception as e:
            print(f"  Warning: Neo4j connection failed: {e}")
            print("  Graph search will be disabled. Run: cd neo4j && ./neo4j-setup.sh 3")
            self.graph = None

    # ─────────────────────────────────────────────────────────────────
    # SEMANTIC SEARCH (ChromaDB)
    # ─────────────────────────────────────────────────────────────────

    def semantic_search(self, query: str, k: int = 3) -> List[Dict]:
        """Semantic search using vector embeddings. Understands MEANING."""
        results = self.collection.query(query_texts=[query], n_results=k,
                                        include=["documents", "metadatas", "distances"])
        return [{"content": results["documents"][0][i],
                 "metadata": results["metadatas"][0][i],
                 "score": 1.0 / (1.0 + results["distances"][0][i]),
                 "source": "semantic"}
                for i in range(len(results["documents"][0]))]

    # ─────────────────────────────────────────────────────────────────
    # GRAPH SEARCH (Neo4j)
    # ─────────────────────────────────────────────────────────────────

    def graph_search(self, query: str, k: int = 5) -> List[Dict]:
        """Graph search using Cypher queries. Understands STRUCTURE."""
        if not self.graph:
            return []

        query_lower = query.lower()
        results = []

        # Determine what to search for based on query
        if "pro-series" in query_lower or "pro series" in query_lower or "enterprise" in query_lower:
            # Find Pro-Series product and related policies/timeframes
            # Filter by Return type if asking about returns, otherwise get all
            policy_filter = "pol.type = 'Return'" if "return" in query_lower else "TRUE"
            # Only get return window timeframe, not refund processing time
            cypher = f"""
            MATCH (prod:Product {{name: 'Pro_Series'}})<-[:APPLIES_TO]-(pol:Policy)
            WHERE {policy_filter}
            OPTIONAL MATCH (pol)-[:HAS_TIMEFRAME]->(tf:TimeFrame)
            WHERE tf.description CONTAINS 'return' OR tf.description IS NULL
            OPTIONAL MATCH (pol)-[:REQUIRES_CONDITION]->(cond:Condition)
            OPTIONAL MATCH (pol)-[:HAS_FEE]->(fee:Fee)
            OPTIONAL MATCH (contact:Contact)-[:HANDLES]->(pol)
            RETURN DISTINCT prod, pol, tf, cond, fee, contact
            """
            data = self.graph.run(cypher).data()
            seen_policies = set()
            for row in data:
                if row.get('pol') and row['pol']['name'] not in seen_policies:
                    seen_policies.add(row['pol']['name'])
                    results.append(self._format_policy_result(row))

        elif "defective" in query_lower or "broken" in query_lower or "doa" in query_lower:
            # Find DOA policy and who handles it
            cypher = """
            MATCH (pol:Policy {name: 'DOA_Policy'})
            OPTIONAL MATCH (pol)-[:HAS_TIMEFRAME]->(tf:TimeFrame)
            OPTIONAL MATCH (pol)-[:APPLIES_TO]->(prod:Product)
            OPTIONAL MATCH (contact:Contact)-[:HANDLES]->(pol)
            RETURN pol, tf, prod, contact
            """
            data = self.graph.run(cypher).data()
            for row in data:
                results.append(self._format_doa_result(row))

        elif "contact" in query_lower or "email" in query_lower or "phone" in query_lower or "who" in query_lower:
            # Find all contacts and what they handle
            cypher = """
            MATCH (c:Contact)
            OPTIONAL MATCH (c)-[:HANDLES]->(target)
            RETURN c, collect(target) as handles
            """
            data = self.graph.run(cypher).data()
            for row in data:
                results.append(self._format_contact_result(row))

        elif "return" in query_lower or "refund" in query_lower:
            # Find all return policies
            cypher = """
            MATCH (pol:Policy)
            WHERE pol.type = 'Return'
            OPTIONAL MATCH (pol)-[:HAS_TIMEFRAME]->(tf:TimeFrame)
            OPTIONAL MATCH (pol)-[:APPLIES_TO]->(prod:Product)
            RETURN pol, tf, collect(DISTINCT prod) as products
            """
            data = self.graph.run(cypher).data()
            for row in data:
                results.append(self._format_return_result(row))

        else:
            # Generic search - find all policies with timeframes
            cypher = """
            MATCH (pol:Policy)-[:HAS_TIMEFRAME]->(tf:TimeFrame)
            RETURN pol, tf
            LIMIT 5
            """
            data = self.graph.run(cypher).data()
            for row in data:
                pol = row['pol']
                tf = row['tf']
                results.append({
                    "content": f"Policy: {pol['name']}\nDescription: {pol['description']}\nTimeframe: {tf['value']}",
                    "metadata": {"node": pol['name'], "type": "Policy"},
                    "score": 0.5,
                    "source": "graph"
                })

        return results[:k]

    def _format_policy_result(self, row) -> Dict:
        """Format a policy query result."""
        pol = row['pol']
        content = f"Policy: {pol['name']}\n"
        content += f"Description: {pol['description']}\n"
        if row.get('tf'):
            content += f"Return Window: {row['tf']['value']}\n"
        if row.get('fee'):
            content += f"Restocking Fee: {row['fee']['value']} - {row['fee']['description']}\n"
        if row.get('cond'):
            content += f"Required Condition: {row['cond']['name']} - {row['cond']['description']}\n"
        if row.get('contact'):
            c = row['contact']
            content += f"Contact: {c['value']}"
            if c.get('hours'):
                content += f" ({c['hours']})"
            content += "\n"
        return {
            "content": content.strip(),
            "metadata": {"node": pol['name'], "type": "Policy"},
            "score": 1.0,
            "source": "graph"
        }

    def _format_doa_result(self, row) -> Dict:
        """Format a DOA policy result."""
        pol = row['pol']
        content = f"Policy: {pol['name']}\n"
        content += f"Description: {pol['description']}\n"
        if row.get('tf'):
            content += f"Report Within: {row['tf']['value']}\n"
        if row.get('contact'):
            c = row['contact']
            content += f"Contact: {c['value']} ({c['department']})"
        return {
            "content": content,
            "metadata": {"node": pol['name'], "type": "Policy"},
            "score": 1.0,
            "source": "graph"
        }

    def _format_contact_result(self, row) -> Dict:
        """Format a contact result."""
        c = row['c']
        content = f"Contact: {c['name']}\n"
        content += f"Value: {c['value']}\n"
        content += f"Type: {c['type']}\n"
        content += f"Department: {c['department']}\n"
        if c.get('hours'):
            content += f"Hours: {c['hours']}\n"
        if row.get('handles'):
            handles = [h['name'] for h in row['handles'] if h]
            if handles:
                content += f"Handles: {', '.join(handles)}"
        return {
            "content": content,
            "metadata": {"node": c['name'], "type": "Contact"},
            "score": 1.0,
            "source": "graph"
        }

    def _format_return_result(self, row) -> Dict:
        """Format a return policy result."""
        pol = row['pol']
        content = f"Policy: {pol['name']}\n"
        content += f"Description: {pol['description']}\n"
        if row.get('tf'):
            content += f"Window: {row['tf']['value']}\n"
        if row.get('products'):
            prods = [p['name'] for p in row['products'] if p]
            if prods:
                content += f"Applies To: {', '.join(prods)}"
        return {
            "content": content,
            "metadata": {"node": pol['name'], "type": "Policy"},
            "score": 1.0,
            "source": "graph"
        }

    # ─────────────────────────────────────────────────────────────────
    # HYBRID SEARCH
    # ─────────────────────────────────────────────────────────────────

    def hybrid_search(self, query: str, k: int = 3) -> List[Dict]:
        """Hybrid search combining semantic + graph results."""
        graph_results = self.graph_search(query, k=k)
        semantic_results = self.semantic_search(query, k=k)

        # Combine: graph first (precision), then semantic (context)
        combined = graph_results + semantic_results
        return combined[:k*2]

    # ─────────────────────────────────────────────────────────────────
    # RAG GENERATION
    # ─────────────────────────────────────────────────────────────────

    def generate_answer(self, question: str, context_chunks: List[Dict]) -> str:
        """Generate an answer using Ollama with retrieved context."""
        graph_context = [c for c in context_chunks if c.get("source") == "graph"]
        semantic_context = [c for c in context_chunks if c.get("source") == "semantic"]

        context_parts = []
        if graph_context:
            context_parts.append("STRUCTURED DATA (from knowledge graph):\n" +
                               "\n---\n".join([c["content"] for c in graph_context]))
        if semantic_context:
            context_parts.append("DOCUMENT CONTEXT:\n" +
                               "\n---\n".join([f"[{c['metadata'].get('source', 'doc').split('/')[-1]}]\n{c['content'][:500]}"
                                         for c in semantic_context]))

        context = "\n\n".join(context_parts)

        prompt = f"""Based on the following information, answer the user's question.

{context}

QUESTION: {question}

Provide a helpful, accurate answer. Use the structured data for precise facts (timeframes, contacts)
and the document context for explanations. If information isn't available, say so."""

        try:
            response = requests.post(OLLAMA_URL, json={
                "model": OLLAMA_MODEL, "prompt": prompt, "stream": False,
                "options": {"temperature": 0.3}
            }, timeout=60)
            if response.status_code == 200:
                return response.json().get("response", "").strip()
            return f"Error: {response.status_code}"
        except Exception as e:
            return f"LLM Error: {e}"

    def rag_query(self, question: str, method: str = "hybrid") -> Dict:
        """Complete RAG: Retrieve → Augment → Generate."""
        if method == "semantic":
            chunks = self.semantic_search(question)
        elif method == "graph":
            chunks = self.graph_search(question)
        else:
            chunks = self.hybrid_search(question)

        answer = self.generate_answer(question, chunks)

        return {
            "answer": answer,
            "chunks": chunks,
            "method": method
        }


# ANSI color codes
RED = "\033[91m"
BLUE = "\033[94m"
GREEN = "\033[92m"
RESET = "\033[0m"
BOLD = "\033[1m"


def run_demo():
    """Interactive hybrid RAG comparison."""
    print(f"{BOLD}Hybrid RAG: Semantic + Graph + Hybrid{RESET}")
    print("=" * 50)

    rag = HybridRAG()

    if not rag.graph:
        print(f"\n{RED}Neo4j not connected. Graph search disabled.{RESET}")
        print("Run: cd /workspaces/rag/neo4j && ./neo4j-setup.sh 3\n")

    print(f"\nEnter queries to compare all 3 methods. Type 'exit' to quit.\n")
    print(f"  {RED}RED{RESET} = Semantic (ChromaDB)")
    print(f"  {BLUE}BLUE{RESET} = Graph (Neo4j)")
    print(f"  {GREEN}GREEN{RESET} = Hybrid (Both)\n")

    while True:
        query = input(f"{BOLD}Query:{RESET} ").strip()

        if query.lower() == "exit":
            print("Goodbye!")
            break

        if not query:
            continue

        print()

        # Semantic
        print(f"{RED}{BOLD}SEMANTIC:{RESET}")
        sem_result = rag.rag_query(query, method="semantic")
        print(f"{RED}{sem_result['answer']}{RESET}")
        print()

        # Graph
        print(f"{BLUE}{BOLD}GRAPH:{RESET}")
        graph_result = rag.rag_query(query, method="graph")
        print(f"{BLUE}{graph_result['answer']}{RESET}")
        print()

        # Hybrid
        print(f"{GREEN}{BOLD}HYBRID:{RESET}")
        hybrid_result = rag.rag_query(query, method="hybrid")
        print(f"{GREEN}{hybrid_result['answer']}{RESET}")
        print()
        print("-" * 50)
        print()


if __name__ == "__main__":
    run_demo()

